"""This function gets the tfidf values for each function in openssl vs the list of functions in openssl for x86 architecture."""
import argparse
import math
import numpy as np
import os


parser = argparse.ArgumentParser(description='Generate function embeddings from GDLs')
parser.add_argument('--input_path', help='input folder with preprocessed GDLs in one-instruction-per-line format')
parser.add_argument('--output_path', help='output folder for generate function embeddings')
parser.add_argument('--output_file_name', help='name of output file')
parser.add_argument('--vecmap_embedding_path', help='path to cross-lingual embeddings for x86 generated by Vecmap')

args = parser.parse_args()

FILE_PATH = args.input_path + '/'
OUTPUT_PATH = args.output_path + '/'
output_file_name = args.output_file_name
vecmap_output = args.vecmap_embedding_path

def asnumpy(x):
    return np.asarray(x)

def write(f_name, matrix, file):
    m = asnumpy(matrix)
    if m.ndim == 0:
        pass
    elif m.ndim > 0:
        # function_name = f_name.split('/')[-1]
        print(f_name + ' ' + ' '.join(['%.6g' % x for x in m]), file=file)

# Raw count of term in a document, term frequency
def computeTF(wordDict, bow):
    tfDict = {}
    bowCount = len(bow)
    for word, count in wordDict.items():
        tfDict[word] = count / float(bowCount)
    return tfDict


# IDFs for x86 For each instruction in a function, if that instruction exists in the other instructions of openssl increase count.
# Do not use the instruction list output of vecmap as a single file, this returns log(1/1) = 0
# Logarithmic value of: number of total documents divided by number of documents that contain the term.
def computeIDF(function, docList):
    idfDict = {}
    N = len(docList)
    idfDict = dict.fromkeys(function.keys(), 0)
    for doc in docList:
        for word, val in doc.items():
            if word in idfDict:
                if val > 0:
                    idfDict[word] += 1
    for word, val in idfDict.items():
        idfDict[word] = math.log(N / float(val))
    return idfDict


def computeTFIDF(tfBow, idfs):
    tfidf = {}
    for word, val in tfBow.items():
        tfidf[word] = val * idfs[word]
    return tfidf

total_OOV = 0
total_VOCAB = 0

all_instr_emb_dict = {}


def prepare_all_instr_emb_dict(vec_output):
    with open(vec_output, 'r') as V:
        output = V.read().splitlines()  # .readlines()
    for line in output[1:]:
        line_word = line.split(' ', 1)[0]
        line_num = line.split(' ', 1)[1]
        line_num = [float(s) for s in line_num.split(' ')]
        all_instr_emb_dict[line_word.strip()] = line_num


def computeFunctionEmbedding(tfidfBow, bow, vec_output, function_name, output_file_path):
    scalars, words, embedding_values, function_embeddings, = [], [], [], []
    global total_OOV, total_VOCAB
    # Get embeddings
    with open(vec_output, 'r') as V:
        output = V.read().splitlines()
    # For each word and value in the tfidf results
    for word, val in tfidfBow.items():
        if word in bow:
            scalars.append(val)
            words.append(word.strip())

    unique_words_set = set(words)
    if '' in unique_words_set:
        unique_words_set.remove('')
    total_VOCAB += len(unique_words_set)
    for unique_word in unique_words_set:
        if unique_word in all_instr_emb_dict:
            line_num = np.multiply(all_instr_emb_dict[unique_word], tfidfBow[unique_word])
            embedding_values.append(line_num)
        else:
            total_OOV += 1
            embedding_values.append(np.asarray([0.0] * 200))

    function_embedding = sum(embedding_values)
    f_name = function_name

    # Print embeddings to file
    outfile = output_file_path + output_file_name  # 'openssl_function_embeddings-tf_only.txt'
    output_emb = open(outfile, mode='a')
    write(f_name, function_embedding, output_emb)


def main():
    prepare_all_instr_emb_dict(vecmap_output)
    FILE_LIST = os.listdir(FILE_PATH)
    if not os.path.exists(OUTPUT_PATH):
        os.makedirs(OUTPUT_PATH)
    DOCUMENT_LIST = []

    # This creates a complete list of functions, and a complete list of words in the functions for openssl x86
    for file in FILE_LIST:
        DOCUMENT_LIST.append(file)
        FILE_NAME = FILE_PATH + "%s" % file

        FUNCTION_NAME = FILE_NAME.split('.txt')[0]
        S1 = FILE_NAME
        with open(S1, 'r') as A:
            openssl_bow = A.read().splitlines()
            with open('openssl_bow.txt', 'a') as tfile:
                for word in openssl_bow:
                    tfile.write(str(word))
                tfile.close()
    with open('openssl_bow.txt', 'r') as D:
        openssl_bow = D.read().splitlines()

    DICTIONARY_LIST = {}
    dict_list = []

    # Creates a wordset and count for words in a function
    for i, file in enumerate(DOCUMENT_LIST):
        FILE_NAME = FILE_PATH + "%s" % file
        FUNCTION_NAME = FILE_NAME.split('.txt')[0]
        S2 = FILE_NAME
        with open(S2, 'r') as B:
            functionB_bow = B.read().splitlines()
        with open('function_bow.txt', 'w') as tfile:
            tfile.write(str(functionB_bow))
            tfile.close()

        functionB_wordSet = set(functionB_bow)

        DICTIONARY_LIST[i] = dict.fromkeys(functionB_wordSet, 0)
        for word in functionB_bow:
            if word in DICTIONARY_LIST[i]:
                DICTIONARY_LIST[i][word] += 1

        dict_list.append(DICTIONARY_LIST[i])

    # For each function in openssl find the tf-idf scalar then multiply that vs each instruction embedding in the function to get the function embedding
    for file in FILE_LIST:
        FILE_NAME = FILE_PATH + "%s" % file
        FUNCTION_NAME = FILE_NAME.split('.txt')[0]

        S3 = FILE_NAME

        with open(S3, 'r') as C:
            function_bow = C.read().splitlines()
            with open('function_bow.txt', 'w') as tfile:
                tfile.write(str(function_bow))
                tfile.close()

        function_wordSet = set(function_bow)

        function_dictionary = dict.fromkeys(function_wordSet, 0)

        for word in function_bow:
            function_dictionary[word] += 1

        function_tf = computeTF(function_dictionary, function_bow)
        idfs = computeIDF(function_dictionary, [*dict_list])
        function_tfidf = computeTFIDF(function_tf, idfs)

        function_embedding = computeFunctionEmbedding(function_tf, function_bow, vecmap_output, file,
                                                      OUTPUT_PATH)

if __name__ == "__main__":
    main()
